# 3.4. Встроенные возможности по работе с коллекциями
A. Автоматизация списка
```python
lst = str(input()).split()
for i, word in enumerate(lst, start=1):
    print(f"{i}. {word}")
```
B. Сборы на прогулку
```python
a, b = input().split(', '), input().split(', ')
for x, y in zip(a, b):
    print(f"{x} - {y}")
```
C. Рациональная считалочка
```python
from itertools import count
start, stop, step = map(float, input().split())
for i in count(start, step):
    if i > stop:
        break
    print(i)
```
D. Словарная ёлка
```python
from itertools import accumulate

lst = [i + ' ' for i in input().split()]
print(*accumulate(lst), sep='\n')
```
E. Список покупок
```python
from itertools import chain

lst = [input().split(', ') for _ in range(3)]
for i, name in enumerate(sorted(list(chain(*lst))), start=1):
    print(f"{i}. {name}")
```
F. Колода карт
```python
from itertools import product

lst = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'валет', 'дама', 'король', 'туз']
masti = ['пик', 'треф', 'бубен', 'червей']
masti.remove(str(input()))
for card in product(lst, masti):
    print(*card, sep=' ')
```
G. Игровая сетка
```python
from itertools import combinations
n = int(input())
lst = [str(input()) for _ in range(n)]
for i in combinations(lst, r=2):
    print(*i, sep=' - ')
```
H. Меню питания 2.0
```python
n = int(input())
lst = [str(input()) for _ in range(n)]
a = int(input())
ans = lst * (a // n) + lst[:a % n]
print(*ans, sep='\n')
```
I. Таблица умножения 3.0
```python
n = int(input())

for i in range(1, n + 1):
    row = []
    for j in range(1, n + 1):
        row.append(i * j)
    print(*row)
```
J. Мы делили апельсин 2.0
```python
n = int(input())
for i in range(1, n - 1):
    if i == 1:
        print('А Б В')
    for j in range(1, n - i):
        print(f'{i} {j} {n - i - j}')
```
K. Числовой прямоугольник 3.0
```python
n, m = int(input()), int(input())
total = n * m
width = len(str(total))

for i in range(n):
    start = i * m + 1
    end = start + m
    row = [str(num).rjust(width) for num in range(start, end)]
    print(*row)
```
L. Список покупок 2.0
```python
n = int(input())
products = list()

for _ in range(n):
    line = input().strip()
    items = line.split(',')
    for item in items:
        products.append(item.strip())

for i, name in enumerate(sorted(products), start=1):
    print(f"{i}. {name}")
```
M. Расстановка спортсменов
```python
from itertools import permutations

items = [str(input()) for _ in range(int(input()))]
for i in sorted(permutations(items)):
    print(', '.join(i))
```
N. Спортивные гадания
```python
from itertools import permutations

lst = [str(input()) for _ in range(int(input()))]
for i in sorted(permutations(lst, 3)):
    print(', '.join(i))
```
O. Список покупок 3.0
```python
from itertools import permutations

lst = []
for _ in range(int(input())):
    for i in str(input()).split(', '):
        lst.append(i)
for i in permutations(sorted(lst), r=3):
    print(' '.join(i))
```
P. Расклад таков...
```python
from itertools import combinations

suits = ["бубен", "пик", "треф", "червей"]
ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "валет", "дама", "король", "туз"]

input_suit = input().strip()
excluded_rank = input().strip()

target_suit = next(s for s in suits if s.startswith(input_suit[:3]))
deck = [(rank, suit) for rank in ranks if rank != excluded_rank for suit in suits]

deck.sort(key=lambda card: (card[0], card[1]))

valid_triads = []
for triad in combinations(deck, 3):
    if any(card[1] == target_suit for card in triad):
        formatted = [f"{rank} {suit}" for rank, suit in triad]
        valid_triads.append(", ".join(formatted))
        if len(valid_triads) == 10:
            break

for triad in valid_triads:
    print(triad)
```
Q. А есть ещё варианты?
```python
from itertools import combinations

SUITS = ["бубен", "пик", "треф", "червей"]
RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "валет", "дама", "король", "туз"]

input_suit = input().strip()
excluded_rank = input().strip()
target_triad_str = input().strip()

target_suit = next(s for s in SUITS if s.startswith(input_suit[:3]))
deck = [(rank, suit) for rank in RANKS if rank != excluded_rank for suit in SUITS]

deck.sort(key=lambda card: (card[0], card[1]))

valid_triads = []
for triad in combinations(deck, 3):
    if any(suit == target_suit for _, suit in triad):
        formatted_cards = [f"{rank} {suit}" for rank, suit in triad]
        formatted_cards.sort()
        triad_str = ", ".join(formatted_cards)
        valid_triads.append(triad_str)

valid_triads.sort()

idx = valid_triads.index(target_triad_str)
print(valid_triads[idx + 1])
```
R. Таблица истинности
```python
expression = str(input())
print('a b c f')
for i in range(8):
    a = i // 4 % 2
    b = i // 2 % 2
    c = i % 2
    print(a, b, c, int(eval(expression)))
```
S. Таблица истинности 2
```python
x = str(input())
args = sorted({c for c in x if c.isupper()})
print(' '.join(args), 'F')

for i in range(2 ** len(args)):
    vals = [(i >> (len(args) - 1 - j)) & 1 for j in range(len(args))]
    env = dict(zip(args, vals))
    print(*vals, int(eval(x, {}, env)))
```
T. Таблицы истинности 3 (Таблица истинности 3)
```python
from itertools import product

OPERATORS = {
    'not': 'not',
    'and': 'and',
    'or': 'or',
    '^': '!=',
    '->': '<=',
    '~': '==',
}

PRIORITY = {
    'not': 0, 'and': 1, 'or': 2, '^': 3, '->': 4, '~': 5, '(': 6,
}


def to_postfix(expression, variables):
    stack, result = [], []
    for token in expression.split():
        if token in variables:
            result.append(token)
        elif token == '(':
            stack.append(token)
        elif token == ')':
            while stack[-1] != '(':
                result.append(OPERATORS[stack.pop()])
            stack.pop()
        elif token in OPERATORS:
            while stack and PRIORITY[token] >= PRIORITY[stack[-1]]:
                result.append(OPERATORS[stack.pop()])
            stack.append(token)

    while stack:
        result.append(OPERATORS[stack.pop()])
    return result


def evaluate_postfix(postfix, variables):
    stack = []
    for token in postfix:
        if token in variables:
            stack.append(variables[token])
        elif token == 'not':
            stack.append(not stack.pop())
        else:
            b, a = stack.pop(), stack.pop()
            stack.append(eval(f'{a} {token} {b}'))
    return int(stack[0])


statement = input()
variables = sorted(set(i for i in statement if i.isupper()))

print(' '.join(variables), 'F')

statement = statement.replace('(', '( ').replace(')', ' )')
postfix = to_postfix(statement, variables)

for values in product([0, 1], repeat=len(variables)):
    value_dict = dict(zip(variables, values))
    result = evaluate_postfix(postfix, value_dict)
    print(' '.join(str(v) for v in values), result)
```