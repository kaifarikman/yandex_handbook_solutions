# 4.2. Позиционные и именованные аргументы. Функции высших порядков. Лямбда-функции

A. Генератор списков
```
def make_list(length, value=0):
    return [value] * length   
```
B. Генератор матриц
```
def make_matrix(size, value=0):
    if isinstance(size, int):
        return [[value for _ in range(size)] for _ in range(size)]
    n, m = size
    return [[value for _ in range(n)] for _ in range(m)]
```
C. Функциональный нод 2.0
```
def gcd(*args):
    lst = list(args)
    while len(lst) > 1:
        while lst[1]:
            lst[0], lst[1] = lst[1], lst[0] % lst[1]
        lst.pop(1)
    return lst[0]
```
D. Имя of the month 2.0
```
def month(num, lang='ru'):
    d = {
        'en': [
            'January', 'February', 'March',
            'April', 'May', 'June',
            'July', 'August', 'September',
            'October', 'November', 'December'
        ],
        'ru': [
            'Январь', 'Февраль', 'Март',
            'Апрель', 'Май', 'Июнь',
            'Июль', 'Август', 'Сентябрь',
            'Октябрь', 'Ноябрь', 'Декабрь'
        ]
    }
    return d[lang][num - 1]
```
E. Подготовка данных
```
def to_string(*args, **kwargs):
    return kwargs.get('sep', ' ').join(list(map(str, args))) + kwargs.get('end', '\n')
```
F. Арифметический помощник
```
def get_operator(operation):
    import operator
    d = {
        '+': operator.add,
        '-': operator.sub,
        '*': operator.mul,
        '//': operator.floordiv,
        '**': operator.pow,
    }
    return d[operation]
```
G. Подготовитель данных
```
def get_formatter(sep=' ', end=''):
    def fmt(*items):
        return sep.join(map(str, items)) + end
    return fmt
```
H. Странный рост
```
def grow(*numbers, **modifiers):
    additions = [0] * len(numbers)
    for name, value in modifiers.items():
        name_len = len(name)
        if not name_len:
            continue
        for i, num in enumerate(numbers):
            if num % name_len == 0:
                additions[i] += value

    return tuple(num + add for num, add in zip(numbers, additions))
```
I. Странное произведение
```
def product(*args, **kwargs):
    lst = []
    for s in args:
        product_value = 1
        flag = False
        for key, value in kwargs.items():
            if key in s:
                product_value *= value
                flag = True
        if flag:
            lst.append(product_value)
    return tuple(lst)
```
J. Наилучший выбор
```
def choice(*args, **kwargs):
    if 'min' in kwargs:
        return min(kwargs['min'](i) for i in args)
    return max(kwargs['max'](i) for i in args)
```
K. Кофейня
```
def order(*customer_preferences):
    global in_stock
    original_stock = in_stock.copy()
    BEVERAGE_RECIPES = {
        "Эспрессо": {"coffee": 1},
        "Капучино": {"coffee": 1, "milk": 3},
        "Макиато": {"coffee": 2, "milk": 1},
        "Кофе по-венски": {"coffee": 1, "cream": 2},
        "Латте Макиато": {"coffee": 1, "milk": 2, "cream": 1},
        "Кон Панна": {"coffee": 1, "cream": 1},
    }
    
    for preferred_drink in customer_preferences:
        ingredients_needed = BEVERAGE_RECIPES[preferred_drink]
        if all(in_stock.get(ingredient, 0) >= amount 
               for ingredient, amount in ingredients_needed.items()):            
            for ingredient, amount in ingredients_needed.items():
                in_stock[ingredient] -= amount
            return preferred_drink
    
    return "К сожалению, не можем предложить Вам напиток"
```
L. В эфире рубрика «Эксперименты»
```
numbers = tuple()


def get_sum():
    return round(sum(numbers[::2]), 2), round(sum(numbers[1::2]), 2)


def get_average():
    return round(2 * get_sum()[0] / len(numbers), 2), round(2 * get_sum()[1] / len(numbers), 2)


def enter_results(*args):
    global numbers
    numbers += args
```
M. Длинная сортировка
```
lambda x: (len(x), x.lower())
```
N. Чётная фильтрация
```
lambda x: sum(int(i) for i in str(x)) % 2 == 0
```
O. Повторюшка
```
def get_repeater(func, count):
    from functools import reduce
    
    def repeater(x):
        return reduce(lambda acc, _: func(acc), range(count), x)

    return repeater
```
P. Обратная связь
```
def login(username, passwd, on_success, on_fail):
    ascii_sum = sum(ord(char) for char in username)
    encoded_val = ascii_sum * len(username)
    hex_value = format(encoded_val, "x") 
    if passwd.lower() == hex_value[::-1].lower():
        on_success(username)
    else:
        on_fail(username)
```
Q. Фильтрация словаря
```
lambda pair: isinstance(pair[1], list) and any(map(lambda el: isinstance(el, int) and not el % 2, pair[1]))
```
R. Преобразование словаря
```
lambda pair: (
    "".join(c for c in str(pair[0]).lower() if c.isalpha()),
    sum(pair[1]) if isinstance(pair[1], (list, tuple, set)) else pair[1],
)
```
S. Ключевой секрет
```
def secret_replace(text, **kwargs):
    ans = ''
    kwargs = {d: (v, 0) for d, v in kwargs.items()}
    for i in text:
        if i in kwargs:
            ans += kwargs[i][0][kwargs[i][1] % len(kwargs[i][0])]
            kwargs[i] = kwargs[i][0], kwargs[i][1] + 1
        else:
            ans += i
    return ans
```
T. База данных пользователей
```
import re
import operator
from datetime import datetime

database = []

OPS = {
    "==": operator.eq,
    "!=": operator.ne,
    ">": operator.gt,
    "<": operator.lt,
    ">=": operator.ge,
    "<=": operator.le,
}


def insert(*users):
    database.extend(users)


def select(*conditions):
    if not conditions:
        return sorted(database, key=lambda u: u["id"])

    result = database.copy()
    for cond in conditions:
        m = re.match(r"^\s*(\w+)\s*(>=|<=|==|!=|>|<)\s*(.+)\s*$", cond)
        if not m:
            continue
        field, op, raw_val = m.groups()
        result = [u for u in result if _check_condition(u, field, op, raw_val)]
    return sorted(result, key=lambda u: u["id"])


def _check_condition(user, field, operator_token, raw_value):
    if field not in user or operator_token not in OPS:
        return False

    op_func = OPS[operator_token]
    user_value = user[field]
    value = raw_value.strip()

    if field == "birth":
        try:
            u_date = datetime.strptime(str(user_value), "%d.%m.%Y")
            v_date = datetime.strptime(value, "%d.%m.%Y")
            return op_func(u_date, v_date)
        except (ValueError, TypeError):
            return False

    def to_number(x):
        if isinstance(x, (int, float)):
            return x
        s = str(x).strip()
        try:
            return int(s)
        except ValueError:
            try:
                return float(s)
            except ValueError:
                return None

    u_num = to_number(user_value)
    v_num = to_number(value)

    if u_num is not None and v_num is not None:
        try:
            return op_func(u_num, v_num)
        except TypeError:
            return False

    try:
        return op_func(str(user_value), value)
    except Exception:
        return False
```
